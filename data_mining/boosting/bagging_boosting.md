### Baggging和Boosting

Baggging和Boosting都是模型融合的方法，可以将弱分类器融合之后形成一个强分类器，而且融合之后的效果会比最好的弱分类器更好。


### Bagging:

先介绍Bagging方法：

1. 从原始样本集中抽取训练集。每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）

2. 每次使用一个训练集得到一个模型，k个训练集共得到k个模型。

3. 对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。（所有模型的重要性相同）

### Boosting：

- AdaBoosting方式每次使用的是全部的样本，每轮训练改变样本的权重。下一轮训练的目标是找到一个函数f来拟合上一轮的残差。当残差足够小或者达到设置的最大迭代次数则停止。Boosting会减小在上一轮训练正确的样本的权重，增大错误样本的权重。（对的残差小，错的残差大）
- 梯度提升的Boosting方式是使用代价函数对上一轮训练出的模型函数f的偏导来拟合残差。

### Bagging，Boosting二者之间的区别

1. 样本选择上：

- Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。

- Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。

2. 样例权重：

- Bagging：使用均匀取样，每个样例的权重相等

- Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。

3. 预测函数：

- Bagging：所有预测函数的权重相等。

- Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。

4. 并行计算：

- Bagging：各个预测函数可以并行生成

- Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。

5. 这个很重要面试被问到了

### 为什么说bagging是减少variance，而boosting是减少bias？

#### Bagging
- Bagging对样本重采样，对每一重采样得到的子样本集训练一个模型，最后取平均。由于子样本集的相似性以及使用的是同种模型，因此各模型有近似相等的bias和variance（事实上，各模型的分布也近似相同，但不独立）。由于$E[\frac{\sum X_i}{n}]=E[X_i]$，所以bagging后的bias和单个子模型的接近，一般来说不能显著降低bias。
- 若各子模型独立，则有$Var(\frac{\sum X_i}{n})=\frac{Var(X_i)}{n}$，此时可以显著降低variance。
- 若各子模型完全相同，则$Var(\frac{\sum X_i}{n})=Var(X_i)$，此时不会降低variance。
- bagging方法得到的各子模型是有一定相关性的，属于上面两个极端状况的中间态，因此可以一定程度降低variance。
- 为了进一步降低variance，Random forest通过随机选取变量子集做拟合的方式de-correlated了各子模型（树），使得variance进一步降低。

#### boosting
- boosting从优化角度来看，是用forward-stagewise这种贪心法去最小化损失函数$L(y, \sum_i a_i f_i(x))$。例如，常见的AdaBoost即等价于用这种方法最小化exponential loss：$L(y,f(x))=exp(-yf(x))$。所谓forward-stagewise，就是在迭代的第n步，求解新的子模型f(x)及步长a（或者叫组合系数），来最小化$L(y,f_{n-1}(x)+af(x))$，这里$f_{n-1}(x)$是前n-1步得到的子模型的和。
- 因此boosting是在sequential地最小化损失函数，其bias自然逐步下降。但由于是采取这种sequential、adaptive的策略，各子模型之间是强相关的，于是子模型之和并不能显著降低variance。所以说boosting主要还是靠降低bias来提升预测精度。